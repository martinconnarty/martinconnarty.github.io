<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Subnet Port Timing Scanner</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f8f9fa; color: #333; }
        .input-panel { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        input[type="text"], input[type="number"] { padding: 12px; border: 2px solid #e0e6ed; border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        input[type="range"] { width: 100%; padding: 10px 0; }
        .slider-container { display: flex; align-items: center; gap: 15px; margin: 15px 0; }
        .slider-value { font-weight: 600; font-size: 18px; min-width: 80px; text-align: center; }
        button { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin: 10px 5px 0 0; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        .status { margin-top: 10px; padding: 10px; border-radius: 6px; background: #d4edda; border: 1px solid #c3e6cb; }
        .results { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        .host-box { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); border-left: 5px solid #007bff; opacity: 0.3; transition: all 0.3s; }
        .host-box.visible { opacity: 1; transform: translateY(0); border-left-color: #28a745; }
        .host-box.hidden { opacity: 0.3; transform: translateY(10px); }
        .host-ip { font-size: 24px; font-weight: 600; margin-bottom: 15px; color: #1a1a1a; }
        .initial-timing { font-size: 18px; font-weight: 500; color: #dc3545; font-family: monospace; }
        .initial-timing.fast { color: #28a745; }
        .initial-timing.open { color: #17a2b8; background: rgba(23,162,184,0.1); padding: 4px 8px; border-radius: 4px; }
        .deep-scan-section { margin-top: 30px; padding-top: 20px; border-top: 2px solid #dee2e6; }
        .deep-results { display: flex; flex-direction: column; gap: 20px; }
        .deep-host-box { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); border-left: 5px solid #28a745; }
        .pills { display: flex; flex-wrap: wrap; gap: 8px; margin: 15px 0; }
        .pill { padding: 8px 16px; border-radius: 20px; text-decoration: none; font-weight: 500; font-size: 14px; transition: all 0.2s; }
        .pill.http { background: #007bff; color: white; }
        .pill.https { background: linear-gradient(135deg, #28a745, #20c997); color: white; }
        .pill.likely { background: linear-gradient(135deg, #ffc107, #fd7e14); color: white; box-shadow: 0 2px 8px rgba(255,193,7,0.4); }
        .pill.open { background: #17a2b8; color: white; box-shadow: 0 2px 8px rgba(23,162,184,0.3); }
        .pill.down { background: #6c757d; color: white; opacity: 0.7; }
        .legend { display: flex; flex-wrap: wrap; gap: 20px; font-size: 14px; margin-top: 20px; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
        .stats { font-size: 14px; color: #666; margin-bottom: 10px; }
        .concurrency-display { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
        #initialTimeout { width: 120px; }
        .input-row { display: flex; gap: 15px; align-items: end; flex-wrap: wrap; }
        .input-col { flex: 1; min-width: 200px; }
    </style>
</head>
<body>
    <h1>Interactive Subnet Port Timing Scanner</h1>
    
    <div class="input-panel">
        <div class="input-row">
            <div class="input-col">
                <label for="subnet">Subnet (CIDR):</label>
                <input type="text" id="subnet" value="192.168.68.0/24">
            </div>
            <div class="input-col">
                <label for="initialTimeout">Timeout (ms):</label>
                <input type="number" id="initialTimeout" value="5000" min="2000" max="15000">
            </div>
        </div>
        <div class="concurrency-display">
            <label for="concurrency">Concurrency:</label>
            <input type="range" id="concurrency" min="5" max="30" value="15">
            <span id="concurrencyValue">15</span>
        </div>
        <button id="phase1Btn">Phase 1: Port 80 Sweep</button>
        <button id="phase2Btn" disabled>Phase 2: Deep Scan Visible</button>
        <div id="status"></div>
        <progress id="progress" value="0" max="100" style="display: none; width: 100%; height: 8px; border-radius: 4px;"></progress>
    </div>

    <div class="slider-container">
        <label>Threshold: </label>
        <input type="range" id="thresholdSlider" min="0" max="100" value="100">
        <span class="slider-value" id="thresholdValue">5000ms</span>
        <span>Max: <span id="maxThreshold">5000</span>ms</span>
    </div>

    <div id="phase1Results" class="results"></div>
    <div id="phase2Results" class="deep-scan-section" style="display: none;">
        <h2>Deep Scan Results</h2>
        <div id="deepResults" class="deep-results"></div>
    </div>

    <div class="legend">
        <div class="legend-item"><span class="legend-color" style="background: #28a745;"></span>Fast connect (<2s)</div>
        <div class="legend-item"><span class="legend-color" style="background: #17a2b8;"></span>Port OPEN (WebSocket success)</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #ffc107, #fd7e14);"></span>Timing anomaly</div>
    </div>

    <script>
        const DEFAULT_SUBNET = '192.168.68.0/24';
        const PORT_80 = 80;
        const WEB_PORTS = [443, 8443, 8000, 8006, 8080, 8008];
        let phase1Results = [];
        let maxTimeout = 5000;
        let isScanning = false;

        // FIXED: Detect ACTUAL WebSocket success vs failure
        async function testPort(ip, port, timeoutMs) {
            return new Promise((resolve) => {
                const start = performance.now();
                const ws = new WebSocket(`wss://${ip}:${port}?probe=1`);
                
                let opened = false;
                let errored = false;
                
                const timeoutId = setTimeout(() => {
                    ws.close();
                    resolve({
                        time: Math.min(timeoutMs, Math.round(performance.now() - start)),
                        status: 'timeout',
                        success: false
                    });
                }, timeoutMs);
                
                ws.onopen = () => {
                    opened = true;
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve({
                        time: Math.round(performance.now() - start),
                        status: 'open',
                        success: true
                    });
                };
                
                ws.onerror = (event) => {
                    errored = true;
                    clearTimeout(timeoutId);
                    resolve({
                        time: Math.round(performance.now() - start),
                        status: 'error',
                        success: false
                    });
                };
                
                ws.onclose = () => {
                    if (!opened && !errored) {
                        clearTimeout(timeoutId);
                        resolve({
                            time: Math.round(performance.now() - start),
                            status: 'closed',
                            success: false
                        });
                    }
                };
            });
        }

        function parseSubnet(cidr) {
            const [net, bits] = cidr.split('/');
            const [a, b, c, d] = net.match(/\d+/g).map(Number);
            const mask = ~((1 << (32 - bits)) - 1);
            const start = (a << 24 | b << 16 | c << 8 | d) & mask;
            const end = start | (~mask >>> 0);
            const ips = [];
            for (let i = start; i <= end; i++) {
                const ip = [(i>>>24)&255, (i>>>16)&255, (i>>>8)&255, i&255].join('.');
                ips.push(ip);
            }
            return ips;
        }

        class Semaphore {
            constructor(concurrency) {
                this.concurrency = concurrency;
                this.queue = [];
                this.active = 0;
            }
            async acquire() {
                return new Promise(resolve => {
                    this.queue.push(resolve);
                    this._processQueue();
                });
            }
            release() {
                this.active--;
                this._processQueue();
            }
            _processQueue() {
                while (this.active < this.concurrency && this.queue.length > 0) {
                    this.active++;
                    this.queue.shift()();
                }
            }
        }

        async function phase1Sweep() {
            const subnetInput = document.getElementById('subnet').value.trim() || DEFAULT_SUBNET;
            const concurrency = parseInt(document.getElementById('concurrency').value);
            const timeout = parseInt(document.getElementById('initialTimeout').value);
            maxTimeout = timeout;

            const btn = document.getElementById('phase1Btn');
            const statusEl = document.getElementById('status');
            const progressEl = document.getElementById('progress');

            isScanning = true;
            btn.disabled = true;
            statusEl.textContent = `Phase 1: Testing port 80 (${concurrency}x parallel)...`;
            progressEl.style.display = 'block';
            progressEl.value = 0;

            try {
                const ips = parseSubnet(subnetInput);
                const semaphore = new Semaphore(concurrency);
                phase1Results = [];

                const promises = ips.map(async (ip, index) => {
                    await semaphore.acquire();
                    const result = await testPort(ip, PORT_80, timeout);
                    semaphore.release();
                    
                    phase1Results.push({ ip, ...result });
                    progressEl.value = ((index + 1) / ips.length) * 100;
                    
                    const status = result.status === 'open' ? 'OPEN' : 
                                  result.time < 1500 ? 'FAST' : 'SLOW';
                    statusEl.textContent = `Phase 1: ${index + 1}/${ips.length} (${ip}: ${result.time}ms ${status})`;
                });

                await Promise.all(promises);
                
                phase1Results.sort((a, b) => a.time - b.time);
                renderPhase1Results();
                
                const opens = phase1Results.filter(r => r.success).length;
                const fasts = phase1Results.filter(r => r.time < maxTimeout * 0.5).length;
                statusEl.innerHTML = `‚úì Phase 1 complete! ${opens} <strong>OPEN</strong> + ${fasts} fast hosts. Drag threshold!`;
                document.getElementById('phase2Btn').disabled = false;
                document.getElementById('thresholdSlider').max = 100;
                document.getElementById('maxThreshold').textContent = maxTimeout;
                
            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
            } finally {
                isScanning = false;
                btn.disabled = false;
                btn.textContent = 'Phase 1: Port 80 Sweep ‚úì';
            }
        }

        function renderPhase1Results() {
            const resultsEl = document.getElementById('phase1Results');
            resultsEl.innerHTML = phase1Results.map(host => `
                <div class="host-box hidden" data-time="${host.time}">
                    <div class="host-ip">${host.ip}</div>
                    <div class="initial-timing ${host.success ? 'open' : (host.time < 1500 ? 'fast' : '')}">
                        Port 80: <strong>${host.time}ms</strong> 
                        ${host.success ? 'üü¢ OPEN' : host.status === 'timeout' ? '‚è∞ TIMEOUT' : '‚ùå ' + host.status}
                    </div>
                </div>
            `).join('');
        }

        async function phase2Deepscan() {
            const visibleBoxes = document.querySelectorAll('.host-box.visible');
            if (visibleBoxes.length === 0) {
                alert('No visible candidates selected! Adjust threshold slider.');
                return;
            }

            const candidates = Array.from(visibleBoxes).map(box => {
                const ip = box.querySelector('.host-ip').textContent;
                return phase1Results.find(r => r.ip === ip);
            });

            const concurrency = parseInt(document.getElementById('concurrency').value);
            const semaphore = new Semaphore(concurrency);
            const deepResults = [];

            document.getElementById('phase2Btn').disabled = true;
            const statusEl = document.getElementById('status');
            statusEl.textContent = `Phase 2: Deep scanning ${candidates.length} hosts...`;

            try {
                const promises = candidates.map(async (cand, index) => {
                    await semaphore.acquire();
                    try {
                        const portTimes = { 80: { time: cand.time, success: cand.success, status: cand.status } };
                        
                        const testPromises = WEB_PORTS.map(port => 
                            testPort(cand.ip, port, maxTimeout).then(result => {
                                portTimes[port] = result;
                                return result;
                            })
                        );
                        
                        await Promise.all(testPromises);
                        
                        // Consider BOTH fast connects AND actual opens as matches
                        const likelyOpen = Object.entries(portTimes)
                            .filter(([p, r]) => r.success || r.time < 2000)
                            .map(([p]) => Number(p));

                        deepResults.push({ ...cand, portTimes, likelyOpen });
                        statusEl.textContent = `Phase 2: ${index + 1}/${candidates.length} (${cand.ip})`;
                    } finally {
                        semaphore.release();
                    }
                });

                await Promise.all(promises);
                renderDeepResults(deepResults);
                document.getElementById('phase2Results').style.display = 'block';
            } finally {
                document.getElementById('phase2Btn').disabled = false;
                document.getElementById('phase2Btn').textContent = 'Phase 2: Deep Scan ‚úì';
            }
        }

        function renderDeepResults(results) {
            const deepEl = document.getElementById('deepResults');
            deepEl.innerHTML = results.map(host => {
                const pills = [
                    `<a href="http://${host.ip}" class="pill http" target="_blank">HTTP:80 ${host.time}ms ${host.success ? 'üü¢' : ''}</a>`
                ];
                
                WEB_PORTS.forEach(port => {
                    const result = host.portTimes[port];
                    const time = result.time;
                    const isLikely = host.likelyOpen.includes(port);
                    const protocol = port === 443 ? `https://${host.ip}` : `https://${host.ip}:${port}`;
                    const status = result.success ? 'open' : 
                                  (time < 2000 ? 'https' : 'down');
                    const icon = result.success ? 'üü¢' : time < 2000 ? '‚ö°' : '‚ùå';
                    pills.push(`<a href="${protocol}" class="pill ${status}" target="_blank">${port} ${time}ms ${icon}</a>`);
                });

                return `
                    <div class="deep-host-box">
                        <div class="host-ip">${host.ip}</div>
                        <div class="stats">Port 80: ${host.time}ms ${host.success ? 'üü¢ OPEN' : host.status}</div>
                        <div class="pills">${pills.join('')}</div>
                    </div>
                `;
            }).join('');
        }

        function updateThreshold() {
            const slider = document.getElementById('thresholdSlider');
            const value = (slider.value / 100) * maxTimeout;
            document.getElementById('thresholdValue').textContent = Math.round(value) + 'ms';
            
            document.querySelectorAll('.host-box').forEach(box => {
                const time = parseInt(box.dataset.time);
                box.classList.toggle('visible', time <= value);
                box.classList.toggle('hidden', time > value);
            });
        }

        // Event listeners
        document.getElementById('phase1Btn').addEventListener('click', phase1Sweep);
        document.getElementById('phase2Btn').addEventListener('click', phase2Deepscan);
        document.getElementById('thresholdSlider').addEventListener('input', updateThreshold);
        document.getElementById('concurrency').addEventListener('input', function() {
            document.getElementById('concurrencyValue').textContent = this.value;
        });
        document.getElementById('initialTimeout').addEventListener('input', function() {
            maxTimeout = parseInt(this.value);
            document.getElementById('maxThreshold').textContent = maxTimeout;
            if (phase1Results.length > 0) updateThreshold();
        });

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('subnet')) {
            document.getElementById('subnet').value = urlParams.get('subnet');
        }
    </script>
</body>
</html>
