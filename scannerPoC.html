<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>/24 Smart HTTPS Scanner</title>
    <style>
        body { font-family: sans-serif; margin: 1.5rem; }
        .ip-section { 
            border: 1px solid #ccc; 
            margin: 1rem 0; 
            padding: 1rem; 
            background: #f9f9f9;
            border-radius: 4px;
        }
        .ip-section h3 { margin-top: 0; color: #333; }
        .port-row { 
            display: flex; 
            margin: 0.3rem 0; 
            align-items: center;
        }
        .port-label { 
            font-family: monospace; 
            min-width: 80px; 
            font-weight: bold;
        }
        .port-time { 
            margin-left: 1rem; 
            font-family: monospace; 
            color: #666;
        }
        .web-link a { 
            color: #0066cc; 
            text-decoration: none; 
            margin-left: 0.5rem;
        }
        .web-link a:hover { text-decoration: underline; }
        .variance-high { color: #d32f2f; font-weight: bold; }
        #status { margin-top: 0.5rem; font-style: italic; }
        #progress { margin-top: 0.5rem; font-family: monospace; }
        select { margin: 0.2rem; }
    </style>
</head>
<body>
    <h1>/24 Smart HTTPS Network Scanner</h1>

    <label>
        Netblock prefix (first three octets, /24):
        <input id="netPrefix" type="text" value="192.168.0" size="12">
    </label>
    <br><br>
    <label>
        Time threshold (ms):
        <input id="threshold" type="number" value="2000" min="0" step="100">
    </label>
    <br><br>
    <label>
        Mode:
        <select id="mode">
            <option value="ports">Manual ports</option>
            <option value="smart">Smart scan</option>
        </select>
    </label>
    <br><br>
    <label id="portsLabel" style="display: block;">
        Ports (comma separated): 
        <input id="ports" type="text" value="443,8006,8443,8000" size="25">
    </label>
    <br><br>
    <button id="start">Start scan</button>
    <button id="clear">Clear</button>

    <p id="status">Status: Idle.</p>
    <p id="progress">Progress: 0/0</p>

    <div id="results"></div>

    <script>
        const startBtn = document.getElementById('start');
        const clearBtn = document.getElementById('clear');
        const netPrefixInput = document.getElementById('netPrefix');
        const thresholdInput = document.getElementById('threshold');
        const modeSelect = document.getElementById('mode');
        const portsInput = document.getElementById('ports');
        const portsLabel = document.getElementById('portsLabel');
        const statusEl = document.getElementById('status');
        const progressEl = document.getElementById('progress');
        const resultsContainer = document.getElementById('results');

        let allResponses = new Map(); // port -> [{ip, time}]
        let p80Baseline = [];
        let currentThreshold = 2000;

        const webPorts = [80, 443, 8006, 8443, 8000, 8080, 3000, 8081];

        function setStatus(msg) {
            statusEl.textContent = "Status: " + msg;
        }

        function updateProgress(completed, total) {
            progressEl.textContent = `Progress: ${completed}/${total}`;
        }

        function getThreshold() {
            return parseInt(thresholdInput.value) || 2000;
        }

        function clearResults() {
            resultsContainer.innerHTML = "";
            allResponses.clear();
            p80Baseline = [];
        }

        function scanPort(ip, port, callback) {
            const protocol = port === 80 ? 'http' : 'https';
            const url = `${protocol}://${ip}:${port}/?t=${Date.now()}`;
            const startTime = performance.now();
            
            fetch(url, {mode: 'no-cors'}).then(() => {
                callback(performance.now() - startTime);
            }).catch(() => {
                callback(performance.now() - startTime);
            });
        }

        function getP80Median() {
            if (p80Baseline.length === 0) return 10000;
            const sorted = p80Baseline.map(t => t.time).sort((a,b) => a - b);
            return sorted[Math.floor(sorted.length / 2)];
        }

        function renderResults() {
            const threshold = getThreshold();
            const p80Median = getP80Median();
            const ipPortMap = {};
            
            // Aggregate ALL responses per IP (no filtering here)
            allResponses.forEach((portData, port) => {
                portData.forEach(({ip, time}) => {
                    if (!ipPortMap[ip]) ipPortMap[ip] = [];
                    ipPortMap[ip].push({port, time, variance: p80Median ? time / p80Median : 1});
                });
            });
            
            resultsContainer.innerHTML = "";
            
            Object.entries(ipPortMap)
                .sort(([ip1, ports1], [ip2, ports2]) => {
                    const score1 = ports1.filter(p => p.time <= threshold).length;
                    const score2 = ports2.filter(p => p.time <= threshold).length;
                    return score2 - score1;
                })
                .forEach(([ip, ports]) => {
                    const fastPorts = ports.filter(p => p.time <= threshold);
                    if (fastPorts.length === 0) return; // Skip IPs with no fast ports
                    
                    const section = document.createElement('div');
                    section.className = 'ip-section';
                    section.innerHTML = `<h3>${ip} (${fastPorts.length}/${ports.length} ports ≤ ${threshold}ms)</h3>`;
                    
                    ports.sort((a,b) => a.time - b.time).forEach(p => {
                        const row = document.createElement('div');
                        row.className = 'port-row';
                        const isWebPort = webPorts.includes(p.port);
                        const varianceClass = p.variance < 0.25 ? 'variance-high' : '';
                        const protocol = p.port === 80 ? 'http' : 'https';
                        
                        row.innerHTML = `
                            <span class="port-label">Port ${p.port}:</span>
                            <span class="${varianceClass}">${p.time.toFixed(0)}ms ${p.variance.toFixed(1)}x</span>
                            ${isWebPort ? `<span class="web-link"><a href="${protocol}://${ip}:${p.port}/" target="_blank" rel="noreferrer">${protocol}://${ip}:${p.port}</a></span>` : ''}
                            <span class="port-time">${p.time > threshold ? '(> threshold)' : ''}</span>
                        `;
                        section.appendChild(row);
                    });
                    
                    resultsContainer.appendChild(section);
                });
        }

        async function smartScan(prefix) {
            setStatus("Phase 1: Port 80 baseline...");
            
            let p80Completed = 0;
            for (let i = 1; i <= 254; i++) {
                const host = prefix + "." + i;
                scanPort(host, 80, (time) => {
                    p80Baseline.push({ip: host, time});
                    p80Completed++;
                    updateProgress(p80Completed, 254);
                    
                    if (p80Completed === 254) {
                        allResponses.set(80, p80Baseline);
                        const p80Median = getP80Median();
                        const outlierIps = p80Baseline
                            .filter(t => t.time <= p80Median / 4)
                            .sort((a,b) => a.time - b.time)
                            .slice(0, 20)
                            .map(t => t.ip);
                        
                        setStatus(`Phase 2: ${outlierIps.length} outliers (≤${Math.round(p80Median/4)}ms) → random ports`);
                        proceedToPhase2(outlierIps, prefix);
                    }
                });
            }
        }

        function proceedToPhase2(outlierIps, prefix) {
            const randomPorts = [777, 999, 1337, 1234, 666, 555, 2222];
            let phase2Total = outlierIps.length * randomPorts.length;
            let phase2Completed = 0;
            
            randomPorts.forEach(port => {
                outlierIps.forEach(ip => {
                    scanPort(ip, port, (time) => {
                        const portData = allResponses.get(port) || [];
                        portData.push({ip, time});
                        allResponses.set(port, portData);
                        
                        phase2Completed++;
                        updateProgress(phase2Completed, phase2Total);
                        
                        if (phase2Completed === phase2Total) {
                            proceedToPhase3(prefix);
                        }
                    });
                });
            });
        }

        function proceedToPhase3(prefix) {
            setStatus("Phase 3: Web ports scan...");
            
            const webPorts = [443, 8006, 8443, 8000, 8080, 3000, 8081];
            let phase3Total = 254 * webPorts.length;
            let phase3Completed = 0;
            
            webPorts.forEach(port => {
                allResponses.set(port, []);
                
                for (let i = 1; i <= 254; i++) {
                    const host = prefix + "." + i;
                    scanPort(host, port, (time) => {
                        const portData = allResponses.get(port);
                        portData.push({ip: host, time});
                        allResponses.set(port, portData);
                        
                        phase3Completed++;
                        updateProgress(phase3Completed, phase3Total);
                        
                        if (phase3Completed === phase3Total) {
                            setStatus("Smart scan complete!");
                            renderResults();
                        }
                    });
                }
            });
        }

        function scanSubnet() {
            const prefix = netPrefixInput.value.trim();
            if (!/^(\d{1,3}\.){2}\d{1,3}$/.test(prefix)) {
                alert("Netblock prefix should look like 192.168.0");
                return;
            }
            
            const mode = modeSelect.value;
            clearResults();
            currentThreshold = getThreshold();
            
            if (mode === 'smart') {
                smartScan(prefix);
            } else {
                const ports = portsInput.value.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
                if (ports.length === 0) {
                    alert("Enter at least one port");
                    return;
                }
                
                let totalRequests = 254 * ports.length;
                let completed = 0;
                
                ports.forEach(port => {
                    allResponses.set(port, []);
                    
                    for (let i = 1; i <= 254; i++) {
                        const host = prefix + "." + i;
                        scanPort(host, port, (time) => {
                            const portData = allResponses.get(port);
                            portData.push({ip: host, time});
                            allResponses.set(port, portData);
                            completed++;
                            updateProgress(completed, totalRequests);
                            
                            if (completed === totalRequests) {
                                setStatus("Manual scan complete!");
                                renderResults();
                            }
                        });
                    }
                });
            }
        }

        // Event listeners
        startBtn.addEventListener('click', scanSubnet);
        clearBtn.addEventListener('click', clearResults);
        thresholdInput.addEventListener('input', renderResults);
        modeSelect.addEventListener('change', function() {
            portsLabel.style.display = this.value === 'ports' ? 'block' : 'none';
        });

        // Initial setup
        modeSelect.dispatchEvent(new Event('change'));
    </script>
</body>
</html>
