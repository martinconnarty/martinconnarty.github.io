<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subnet Port Timing Scanner</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f8f9fa; color: #333; }
        .input-panel { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        input[type="text"] { width: 100%; padding: 12px; border: 2px solid #e0e6ed; border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        button { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin-top: 10px; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        .status { margin-top: 10px; padding: 10px; border-radius: 6px; }
        .status.running { background: #fff3cd; border: 1px solid #ffeaa7; }
        .status.error { background: #f8d7da; border: 1px solid #f5c6cb; }
        .results { display: flex; flex-direction: column; gap: 20px; }
        .host-box { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); border-left: 5px solid #007bff; }
        .host-ip { font-size: 24px; font-weight: 600; margin-bottom: 10px; color: #1a1a1a; }
        .timings { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .port-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #f8f9fa; border-radius: 6px; font-family: monospace; }
        .port-num { font-weight: 500; color: #495057; }
        .time-ms { font-weight: 600; color: #28a745; }
        .timeout { color: #dc3545; font-weight: 500; }
        .pills { display: flex; flex-wrap: wrap; gap: 8px; }
        .pill { padding: 8px 16px; border-radius: 20px; text-decoration: none; font-weight: 500; font-size: 14px; transition: all 0.2s; }
        .pill.http { background: #007bff; color: white; }
        .pill.https { background: linear-gradient(135deg, #28a745, #20c997); color: white; }
        .pill.likely { background: linear-gradient(135deg, #ffc107, #fd7e14); color: white; box-shadow: 0 2px 8px rgba(255,193,7,0.4); }
        .pill.down { background: #6c757d; color: white; opacity: 0.7; }
        .legend { display: flex; gap: 20px; font-size: 14px; margin-top: 20px; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
        progress { width: 100%; height: 8px; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>Subnet Port Timing Scanner</h1>
    
    <div class="input-panel">
        <label for="subnet">Subnet (CIDR):</label>
        <input type="text" id="subnet" value="192.168.68.0/24" placeholder="e.g. 192.168.68.0/24">
        <button id="scanBtn">Start Port Sweep</button>
        <div id="status"></div>
        <progress id="progress" value="0" max="100" style="display: none;"></progress>
    </div>

    <div id="results" class="results"></div>

    <div class="legend">
        <div class="legend-item"><span class="legend-color" style="background: #007bff;"></span>HTTP (80) - Confirmed</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #28a745, #20c997);"></span>HTTPS - Likely open</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #ffc107, #fd7e14);"></span>Timing anomaly (possible open)</div>
        <div class="legend-item"><span class="legend-color" style="background: #6c757d;"></span>Timeout / Filtered</div>
    </div>

    <script>
        const DEFAULT_SUBNET = '192.168.68.0/24';
        const PORT_80 = 80;
        const WEB_PORTS = [443, 8443, 8000, 8006, 8080, 8008];
        const BASELINE_PORTS = [21, 25, 53, 123]; // Non-web TCP ports for baseline
        const TIMEOUT_MS = 3000;
        const FAST_THRESHOLD = 1500; // ms - ports responding under this are "fast"
        const CANDIDATE_THRESHOLD = 1.5; // Timing ratio vs baseline for "likely open"

        let isScanning = false;

        // Parse CIDR to IP range
        function parseSubnet(cidr) {
            const [net, bits] = cidr.split('/');
            const [a, b, c, d] = net.match(/\d+/g).map(Number);
            const mask = ~((1 << (32 - bits)) - 1);
            const start = (a << 24 | b << 16 | c << 8 | d) & mask;
            const end = start | (~mask >>> 0);
            const ips = [];
            for (let i = start; i <= end; i++) {
                const ip = [
                    (i >>> 24) & 255,
                    (i >>> 16) & 255,
                    (i >>> 8) & 255,
                    i & 255
                ].join('.');
                ips.push(ip);
            }
            return ips;
        }

        // Test single port timing
        async function testPort(ip, port) {
            const start = performance.now();
            try {
                const url = port === 80 ? `http://${ip}` : `https://${ip}:${port}`;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                
                await fetch(url, {
                    method: 'HEAD',
                    signal: controller.signal,
                    mode: 'no-cors' // Important for cross-origin timing
                });
                clearTimeout(timeoutId);
                return Math.round(performance.now() - start);
            } catch (e) {
                return TIMEOUT_MS;
            }
        }

        // Get baseline timing for IP (average of baseline ports)
        async function getBaseline(ip) {
            const times = await Promise.all(BASELINE_PORTS.map(p => testPort(ip, p)));
            return times.reduce((a, b) => a + b, 0) / times.length;
        }

        // Sweep phase 1: Find fast hosts on port 80
        async function phase1Sweep(ips) {
            const statusEl = document.getElementById('status');
            const progressEl = document.getElementById('progress');
            progressEl.style.display = 'block';
            
            const candidates = [];
            for (let i = 0; i < ips.length; i++) {
                const ip = ips[i];
                statusEl.textContent = `Phase 1: Scanning ${ip} (${i + 1}/${ips.length})`;
                progressEl.value = (i / ips.length) * 50;
                
                const time80 = await testPort(ip, PORT_80);
                if (time80 < FAST_THRESHOLD) {
                    candidates.push({ ip, time80, baseline: await getBaseline(ip) });
                }
                await new Promise(r => setTimeout(r, 50)); // Rate limit
            }
            progressEl.value = 50;
            return candidates;
        }

        // Phase 2: Deep scan web ports on candidates
        async function phase2Deepscan(candidates) {
            const statusEl = document.getElementById('status');
            const progressEl = document.getElementById('progress');
            
            const results = [];
            for (let i = 0; i < candidates.length; i++) {
                const cand = candidates[i];
                statusEl.textContent = `Phase 2: Deep scanning ${cand.ip} (${i + 1}/${candidates.length})`;
                progressEl.value = 50 + (i / candidates.length) * 50;
                
                const portTimes = { 80: cand.time80 };
                const allWebTimes = [cand.time80];
                
                for (const port of WEB_PORTS) {
                    const time = await testPort(cand.ip, port);
                    portTimes[port] = time;
                    allWebTimes.push(time);
                }
                
                // Determine likely open ports (faster than baseline * threshold)
                const avgBaseline = cand.baseline;
                const likelyOpen = Object.entries(portTimes)
                    .filter(([p, t]) => t < avgBaseline * CANDIDATE_THRESHOLD && t < TIMEOUT_MS * 0.8)
                    .map(([p]) => Number(p));
                
                results.push({ ...cand, portTimes, likelyOpen });
                await new Promise(r => setTimeout(r, 100)); // Rate limit
            }
            return results;
        }

        // Render results
        function renderResults(hosts) {
            const resultsEl = document.getElementById('results');
            resultsEl.innerHTML = '';
            
            hosts.forEach(host => {
                const box = document.createElement('div');
                box.className = 'host-box';
                
                const pills = [];
                // Port 80 link (always if candidate)
                pills.push(`<a href="http://${host.ip}" class="pill http" target="_blank">HTTP:80 (${host.time80}ms)</a>`);
                
                // Other web ports
                WEB_PORTS.forEach(port => {
                    const time = host.portTimes[port];
                    const isLikely = host.likelyOpen.includes(port);
                    const protocol = port === 443 ? 'https://' : `https://${host.ip}:${port}`;
                    const status = isLikely ? 'likely' : (time >= TIMEOUT_MS ? 'down' : 'down');
                    pills.push(`<a href="${protocol}" class="pill ${status}" target="_blank">${port} (${time}ms)</a>`);
                });
                
                box.innerHTML = `
                    <div class="host-ip">${host.ip}</div>
                    <div class="pills">${pills.join('')}</div>
                    <div class="timings">
                        ${Object.entries(host.portTimes).map(([p, t]) => 
                            `<div class="port-row">
                                <span class="port-num">Port ${p}</span>
                                <span class="time-ms ${t >= TIMEOUT_MS ? 'timeout' : ''}">${t}ms</span>
                            </div>`
                        ).join('')}
                        <div class="port-row">
                            <span class="port-num">Baseline avg</span>
                            <span class="time-ms">${Math.round(host.baseline)}ms</span>
                        </div>
                    </div>
                `;
                resultsEl.appendChild(box);
            });
        }

        // Main scan function
        async function runScan() {
            const subnetInput = document.getElementById('subnet').value.trim();
            const subnet = subnetInput || DEFAULT_SUBNET;
            
            const btn = document.getElementById('scanBtn');
            const statusEl = document.getElementById('status');
            
            if (isScanning) return;
            isScanning = true;
            btn.disabled = true;
            btn.textContent = 'Scanning...';
            statusEl.className = 'status running';
            statusEl.textContent = 'Parsing subnet...';
            
            try {
                const ips = parseSubnet(subnet);
                statusEl.textContent = `Found ${ips.length} IPs. Starting phase 1 sweep...`;
                
                const candidates = await phase1Sweep(ips);
                statusEl.textContent = `Phase 1 complete. ${candidates.length} fast hosts found. Phase 2 deep scan...`;
                
                const results = await phase2Deepscan(candidates);
                statusEl.textContent = `Scan complete! ${results.length} hosts analyzed.`;
                
                renderResults(results);
            } catch (error) {
                statusEl.className = 'status error';
                statusEl.textContent = `Error: ${error.message}`;
            } finally {
                isScanning = false;
                btn.disabled = false;
                btn.textContent = 'Start Port Sweep';
                document.getElementById('progress').style.display = 'none';
            }
        }

        // Event listeners
        document.getElementById('scanBtn').addEventListener('click', runScan);

        // URL params support
        const urlParams = new URLSearchParams(window.location.search);
        const subnetParam = urlParams.get('subnet');
        if (subnetParam) {
            document.getElementById('subnet').value = subnetParam;
        }

        // Save to URL on change
        document.getElementById('subnet').addEventListener('change', function() {
            const url = new URL(window.location);
            if (this.value) {
                url.searchParams.set('subnet', this.value);
            } else {
                url.searchParams.delete('subnet');
            }
            window.history.replaceState({}, '', url);
        });
    </script>
</body>
</html>
