<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subnet Port Timing Scanner</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f8f9fa; color: #333; }
        .input-panel { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        input[type="text"] { width: 100%; padding: 12px; border: 2px solid #e0e6ed; border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        button { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin-top: 10px; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        .status { margin-top: 10px; padding: 10px; border-radius: 6px; }
        .status.running { background: #fff3cd; border: 1px solid #ffeaa7; }
        .status.error { background: #f8d7da; border: 1px solid #f5c6cb; }
        .results { display: flex; flex-direction: column; gap: 20px; }
        .host-box { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); border-left: 5px solid #007bff; }
        .host-ip { font-size: 24px; font-weight: 600; margin-bottom: 10px; color: #1a1a1a; }
        .timings { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .port-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #f8f9fa; border-radius: 6px; font-family: monospace; }
        .port-num { font-weight: 500; color: #495057; }
        .time-ms { font-weight: 600; color: #28a745; }
        .timeout { color: #dc3545; font-weight: 500; }
        .pills { display: flex; flex-wrap: wrap; gap: 8px; }
        .pill { padding: 8px 16px; border-radius: 20px; text-decoration: none; font-weight: 500; font-size: 14px; transition: all 0.2s; }
        .pill.http { background: #007bff; color: white; }
        .pill.https { background: linear-gradient(135deg, #28a745, #20c997); color: white; }
        .pill.likely { background: linear-gradient(135deg, #ffc107, #fd7e14); color: white; box-shadow: 0 2px 8px rgba(255,193,7,0.4); }
        .pill.down { background: #6c757d; color: white; opacity: 0.7; }
        .legend { display: flex; gap: 20px; font-size: 14px; margin-top: 20px; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
        progress { width: 100%; height: 8px; border-radius: 4px; }
        .stats { font-size: 14px; color: #666; margin-bottom: 10px; }
        .parallel-info { font-size: 12px; color: #666; margin-top: 5px; }
    </style>
</head>
<body>
    <h1>Subnet Port Timing Scanner</h1>
    
    <div class="input-panel">
        <label for="subnet">Subnet (CIDR):</label>
        <input type="text" id="subnet" value="192.168.68.0/24" placeholder="e.g. 192.168.68.0/24">
        <label for="concurrency">Concurrency:</label>
        <input type="range" id="concurrency" min="5" max="50" value="20" style="width: 100%;">
        <span id="concurrencyValue">20</span> parallel requests
        <div class="parallel-info">Higher = faster but may trigger browser/network limits</div>
        <button id="scanBtn">Start Parallel Port Sweep</button>
        <div id="status"></div>
        <progress id="progress" value="0" max="100" style="display: none;"></progress>
    </div>

    <div id="results" class="results"></div>

    <div class="legend">
        <div class="legend-item"><span class="legend-color" style="background: #007bff;"></span>HTTP (80) - Fast response</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #28a745, #20c997);"></span>HTTPS - Likely open</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #ffc107, #fd7e14);"></span>Timing anomaly</div>
        <div class="legend-item"><span class="legend-color" style="background: #6c757d;"></span>Timeout / Slow</div>
    </div>

    <script>
        const DEFAULT_SUBNET = '192.168.68.0/24';
        const PORT_80 = 80;
        const WEB_PORTS = [443, 8443, 8000, 8006, 8080, 8008];
        const BASELINE_PORTS = [123, 161, 179];
        const TIMEOUT_MS = 3000;
        const SUBNET_BASELINE_SAMPLES = 10;
        const FAST_THRESHOLD_FACTOR = 2;
        const LIKELY_OPEN_FACTOR = 1.3;

        let isScanning = false;
        let subnetBaseline = null;

        // Parse CIDR to IP range
        function parseSubnet(cidr) {
            const [net, bits] = cidr.split('/');
            const [a, b, c, d] = net.match(/\d+/g).map(Number);
            const mask = ~((1 << (32 - bits)) - 1);
            const start = (a << 24 | b << 16 | c << 8 | d) & mask;
            const end = start | (~mask >>> 0);
            const ips = [];
            for (let i = start; i <= end; i++) {
                const ip = [
                    (i >>> 24) & 255,
                    (i >>> 16) & 255,
                    (i >>> 8) & 255,
                    i & 255
                ].join('.');
                ips.push(ip);
            }
            return ips;
        }

        // FIXED: All requests use HTTPS regardless of port
        async function testPort(ip, port) {
            const start = performance.now();
            try {
                // ALWAYS HTTPS - even for port 80 timing baseline
                const url = `https://${ip}:${port}/favicon.ico`;
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                
                await fetch(url, {
                    method: 'GET',
                    signal: controller.signal,
                    mode: 'no-cors',
                    cache: 'no-cache'
                });
                clearTimeout(timeoutId);
                
                return Math.round(performance.now() - start);
            } catch (e) {
                return TIMEOUT_MS;
            }
        }

        // Parallel semaphore for controlled concurrency
        class Semaphore {
            constructor(concurrency) {
                this.concurrency = concurrency;
                this.queue = [];
                this.active = 0;
            }
            
            async acquire() {
                return new Promise(resolve => {
                    this.queue.push(resolve);
                    this._processQueue();
                });
            }
            
            release() {
                this.active--;
                this._processQueue();
            }
            
            _processQueue() {
                while (this.active < this.concurrency && this.queue.length > 0) {
                    this.active++;
                    this.queue.shift()();
                }
            }
        }

        // Parallel baseline calculation
        async function calculateSubnetBaseline(ips, semaphore) {
            const sampleIps = ips.slice(0, Math.min(SUBNET_BASELINE_SAMPLES, ips.length));
            const allTimes = [];
            
            const baselinePromises = sampleIps.flatMap(ip => 
                BASELINE_PORTS.map(port => 
                    semaphore.acquire().then(async () => {
                        const time = await testPort(ip, port);
                        allTimes.push(time);
                        semaphore.release();
                        return time;
                    })
                )
            );
            
            await Promise.all(baselinePromises);
            return allTimes.reduce((a, b) => a + b, 0) / allTimes.length;
        }

        // Parallel Phase 1 with concurrency
        async function phase1Sweep(ips, concurrency) {
            const semaphore = new Semaphore(concurrency);
            subnetBaseline = await calculateSubnetBaseline(ips, semaphore);
            
            const statusEl = document.getElementById('status');
            statusEl.textContent = `Subnet baseline: ${Math.round(subnetBaseline)}ms`;
            
            const candidates = [];
            const phase1Promises = ips.map((ip, index) => 
                semaphore.acquire().then(async () => {
                    const time80 = await testPort(ip, PORT_80);
                    semaphore.release();
                    
                    if (time80 < subnetBaseline * FAST_THRESHOLD_FACTOR && time80 < 2000) {
                        candidates.push({ ip, time80 });
                    }
                    
                    // Update progress
                    document.getElementById('progress').value = (index / ips.length) * 50;
                    
                    return time80;
                })
            );
            
            await Promise.all(phase1Promises);
            document.getElementById('progress').value = 50;
            return candidates;
        }

        // Parallel Phase 2
        async function phase2Deepscan(candidates, concurrency) {
            const semaphore = new Semaphore(concurrency);
            const results = [];
            
            const deepscanPromises = candidates.map(async (cand, index) => {
                await semaphore.acquire();
                
                try {
                    // Parallel baseline for this IP
                    const baselinePromises = BASELINE_PORTS.map(p => testPort(cand.ip, p));
                    const baselineTimes = await Promise.all(baselinePromises);
                    const ipBaseline = baselineTimes.reduce((a, b) => a + b, 0) / baselineTimes.length;
                    
                    // Parallel web ports
                    const webPromises = WEB_PORTS.map(port => testPort(cand.ip, port));
                    const webTimes = await Promise.all(webPromises);
                    
                    const portTimes = { 80: cand.time80 };
                    WEB_PORTS.forEach((port, idx) => {
                        portTimes[port] = webTimes[idx];
                    });
                    
                    const likelyOpen = Object.entries(portTimes)
                        .filter(([p, t]) => Number(t) < ipBaseline * LIKELY_OPEN_FACTOR && Number(t) < TIMEOUT_MS * 0.8)
                        .map(([p]) => Number(p));
                    
                    results.push({ 
                        ...cand, 
                        portTimes, 
                        ipBaseline: Math.round(ipBaseline),
                        subnetBaseline: Math.round(subnetBaseline),
                        likelyOpen 
                    });
                    
                    document.getElementById('progress').value = 50 + (index / candidates.length) * 50;
                } finally {
                    semaphore.release();
                }
            });
            
            await Promise.all(deepscanPromises);
            return results;
        }

        // Render results (unchanged)
        function renderResults(hosts) {
            const resultsEl = document.getElementById('results');
            resultsEl.innerHTML = '';
            
            hosts.forEach(host => {
                const box = document.createElement('div');
                box.className = 'host-box';
                
                const pills = [
                    `<a href="http://${host.ip}" class="pill http" target="_blank">HTTP:80 (${host.time80}ms)</a>`
                ];
                
                WEB_PORTS.forEach(port => {
                    const time = host.portTimes[port];
                    const isLikely = host.likelyOpen.includes(port);
                    const protocol = port === 443 ? `https://${host.ip}` : `https://${host.ip}:${port}`;
                    const status = isLikely ? 'https' : (time >= TIMEOUT_MS ? 'down' : 'down');
                    pills.push(`<a href="${protocol}" class="pill ${status}" target="_blank">${port} (${time}ms)</a>`);
                });
                
                box.innerHTML = `
                    <div class="host-ip">${host.ip}</div>
                    <div class="stats">
                        Subnet: ${host.subnetBaseline}ms | IP baseline: ${host.ipBaseline}ms
                    </div>
                    <div class="pills">${pills.join('')}</div>
                    <div class="timings">
                        ${Object.entries(host.portTimes).map(([p, t]) => 
                            `<div class="port-row">
                                <span class="port-num">Port ${p}</span>
                                <span class="time-ms ${t >= TIMEOUT_MS ? 'timeout' : ''}">${t}ms</span>
                            </div>`
                        ).join('')}
                        <div class="port-row">
                            <span class="port-num">IP baseline</span>
                            <span class="time-ms">${host.ipBaseline}ms</span>
                        </div>
                    </div>
                `;
                resultsEl.appendChild(box);
            });
        }

        // Main scan function
        async function runScan() {
            const subnetInput = document.getElementById('subnet').value.trim() || DEFAULT_SUBNET;
            const concurrency = parseInt(document.getElementById('concurrency').value);
            
            const btn = document.getElementById('scanBtn');
            const statusEl = document.getElementById('status');
            
            if (isScanning) return;
            isScanning = true;
            btn.disabled = true;
            btn.textContent = 'Scanning...';
            statusEl.className = 'status running';
            statusEl.textContent = 'Parsing subnet...';
            
            try {
                const ips = parseSubnet(subnetInput);
                statusEl.textContent = `Found ${ips.length} IPs. Parallel scanning (${concurrency} concurrent)...`;
                
                document.getElementById('progress').style.display = 'block';
                document.getElementById('progress').value = 0;
                
                const candidates = await phase1Sweep(ips, concurrency);
                
                if (candidates.length === 0) {
                    statusEl.textContent = `No fast hosts found. Subnet baseline: ${Math.round(subnetBaseline)}ms`;
                    return;
                }
                
                statusEl.textContent = `${candidates.length} candidates. Deep scanning...`;
                const results = await phase2Deepscan(candidates, concurrency);
                
                renderResults(results);
                statusEl.textContent = `Complete! ${results.length} hosts analyzed (${concurrency}x parallel)`;
            } catch (error) {
                statusEl.className = 'status error';
                statusEl.textContent = `Error: ${error.message}`;
            } finally {
                isScanning = false;
                btn.disabled = false;
                btn.textContent = 'Start Parallel Port Sweep';
                document.getElementById('progress').style.display = 'none';
            }
        }

        // Event listeners
        document.getElementById('scanBtn').addEventListener('click', runScan);
        document.getElementById('concurrency').addEventListener('input', function() {
            document.getElementById('concurrencyValue').textContent = this.value;
        });

        // URL params support
        const urlParams = new URLSearchParams(window.location.search);
        const subnetParam = urlParams.get('subnet');
        if (subnetParam) {
            document.getElementById('subnet').value = subnetParam;
        }

        document.getElementById('subnet').addEventListener('change', function() {
            const url = new URL(window.location);
            if (this.value) {
                url.searchParams.set('subnet', this.value);
            } else {
                url.searchParams.delete('subnet');
            }
            window.history.replaceState({}, '', url);
        });
    </script>
</body>
</html>
