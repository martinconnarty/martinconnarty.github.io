<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>/24 Smart HTTPS Scanner - IP Summary View</title>
    <style>
        body { font-family: sans-serif; margin: 1.5rem; }
        table { border-collapse: collapse; width: 100%; margin-top: 1rem; }
        th, td { border: 1px solid #ccc; padding: 0.5rem; text-align: left; }
        th { background: #f0f0f0; cursor: pointer; user-select: none; }
        th:hover { background: #e0e0e0; }
        a { color: #0066cc; text-decoration: none; }
        a:hover { text-decoration: underline; }
        #status { margin-top: 0.5rem; font-style: italic; }
        #progress { margin-top: 0.5rem; font-family: monospace; }
        .fast-row { background: #d4edda !important; }
        .outlier-row { background: #fff3cd !important; }
        .multi-port { background: #d1ecf1 !important; font-weight: bold; }
        .sorted-asc::after { content: " ▲"; }
        .sorted-desc::after { content: " ▼"; }
        .port-section { margin-top: 2rem; border-top: 2px solid #eee; padding-top: 1rem; }
        select { margin: 0.2rem; }
        #ipSummary { margin-top: 3rem; }
        .port-list { font-family: monospace; }
        .port-badge { 
            display: inline-block; 
            background: #e9ecef; 
            padding: 0.2rem 0.4rem; 
            margin: 0.1rem; 
            border-radius: 3px; 
            font-size: 0.85em;
        }
        .hidden { display: none; }
    </style>
</head>
<body>
    <h1>/24 Smart HTTPS Network Scanner - IP Summary View</h1>

    <label>
        Netblock prefix (first three octets, /24):
        <input id="netPrefix" type="text" value="192.168.0" size="12">
    </label>
    <br><br>
    <label>
        Time threshold (ms):
        <input id="threshold" type="number" value="5000" min="0" step="100">
    </label>
    <br><br>
    <label>
        Mode:
        <select id="mode">
            <option value="ports">Manual ports</option>
            <option value="smart">Smart scan</option>
        </select>
    </label>
    <br><br>
    <label id="portsLabel" style="display: block;">
        Ports (comma separated): 
        <input id="ports" type="text" value="443,8006,8443,8000" size="25">
    </label>
    <br><br>
    <button id="start">Start scan</button>
    <button id="clear">Clear</button>

    <p id="status">Status: Idle.</p>
    <p id="progress">Progress: 0/0</p>

    <div id="portTables"></div>
    <div id="ipSummary">
        <h2>All IPs Summary (sortable)</h2>
        <table id="ipSummaryTable">
            <thead>
                <tr>
                    <th>IP</th>
                    <th>Fast Ports (&lt;1s)</th>
                    <th>Port Details</th>
                    <th>Min Time (ms)</th>
                    <th>Links</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <script>
        const startBtn = document.getElementById('start');
        const clearBtn = document.getElementById('clear');
        const netPrefixInput = document.getElementById('netPrefix');
        const thresholdInput = document.getElementById('threshold');
        const modeSelect = document.getElementById('mode');
        const portsInput = document.getElementById('ports');
        const portsLabel = document.getElementById('portsLabel');
        const statusEl = document.getElementById('status');
        const progressEl = document.getElementById('progress');
        const portTablesContainer = document.getElementById('portTables');
        const ipSummaryBody = document.querySelector('#ipSummaryTable tbody');

        let allResponses = new Map(); // port -> [{ip, time}]
        let ipSummaryData = []; // [{ip, fastPorts, minTime, details, links}]
        let mainSortCol = 0;
        let mainSortDir = 'asc';

        function setStatus(msg) {
            statusEl.textContent = "Status: " + msg;
        }

        function updateProgress(completed, total) {
            progressEl.textContent = `Progress: ${completed}/${total}`;
        }

        function getThreshold() {
            return parseInt(thresholdInput.value) || 5000;
        }

        function getPorts(mode) {
            if (mode === 'ports') {
                return portsInput.value.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
            }
            return null;
        }

        function clearTables() {
            portTablesContainer.innerHTML = "";
            ipSummaryBody.innerHTML = "";
            allResponses.clear();
            ipSummaryData = [];
        }

        function createPortTable(port, label = '') {
            const section = document.createElement('div');
            section.className = 'port-section';
            section.innerHTML = `
                <h2>${label || `Port ${port}`} (sortable)</h2>
                <table id="table-${port}">
                    <thead>
                        <tr>
                            <th>IP</th>
                            <th>HTTPS Link</th>
                            <th>Time (ms)</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            `;
            portTablesContainer.appendChild(section);
            
            const table = section.querySelector('table');
            const headers = table.querySelectorAll('th');
            headers[0].addEventListener('click', () => sortPortTable(port, 0));
            headers[2].addEventListener('click', () => sortPortTable(port, 2));
        }

        function filterAndRenderPortTable(port) {
            const tbody = document.querySelector(`#table-${port} tbody`);
            if (!tbody) return;
            
            const threshold = getThreshold();
            const portData = allResponses.get(port) || [];
            
            const filtered = portData.filter(r => r.time <= threshold);
            const sorted = [...filtered].sort((a, b) => {
                const col = mainSortCol;
                const aVal = col === 0 ? a.ip : a.time;
                const bVal = col === 0 ? b.ip : b.time;
                return mainSortDir === 'asc' ? 
                    (aVal < bVal ? -1 : 1) : 
                    (bVal < aVal ? -1 : 1);
            });

            tbody.innerHTML = "";
            sorted.forEach(({ip, time}, idx) => {
                const row = tbody.insertRow();
                if (idx < 10) row.className = 'fast-row';
                row.innerHTML = `
                    <td>${ip}</td>
                    <td><a href="${port === 80 ? 'http' : 'https'}://${ip}:${port}/" target="_blank" rel="noreferrer">${port === 80 ? 'http' : 'https'}://${ip}:${port}</a></td>
                    <td>${time.toFixed(0)}</td>
                `;
            });
        }

        function sortPortTable(port, colIndex) {
            const isAsc = mainSortCol === colIndex && mainSortDir === 'asc';
            mainSortDir = isAsc ? 'desc' : 'asc';
            mainSortCol = colIndex;
            filterAndRenderPortTable(port);
        }

        function updateIPSummary() {
            const fastIps = new Map();
            const allIPData = new Map();
            
            // Collect fast ports per IP
            allResponses.forEach((portData, port) => {
                const fastResponses = portData.filter(r => r.time < 1000);
                fastResponses.forEach(({ip, time}) => {
                    if (!fastIps.has(ip)) fastIps.set(ip, []);
                    fastIps.get(ip).push({port, time});
                });
                
                // Collect all data for this IP
                portData.forEach(({ip, time}) => {
                    if (!allIPData.has(ip)) allIPData.set(ip, []);
                    allIPData.get(ip).push({port, time});
                });
            });

            // Build summary data
            ipSummaryData = Array.from(allIPData.keys()).map(ip => {
                const fastPorts = fastIps.get(ip) || [];
                const allData = allIPData.get(ip);
                const minTime = Math.min(...allData.map(d => d.time));
                
                const fastPortList = fastPorts.map(p => p.port).sort((a,b) => a-b);
                const portDetails = allData.map(d => `${d.port}:${d.time.toFixed(0)}ms`).join(', ');
                
                const links = fastPortList.map(port => 
                    `<span class="port-badge"><a href="${port === 80 ? 'http' : 'https'}://${ip}:${port}/" target="_blank">${port}</a></span>`
                ).join('');
                
                return {
                    ip,
                    fastPorts: fastPortList.length,
                    minTime,
                    details: portDetails,
                    links,
                    fastPortList
                };
            }).sort((a,b) => b.fastPorts - a.fastPorts || a.minTime - b.minTime);

            renderIPSummaryTable();
        }

        function renderIPSummaryTable() {
            const threshold = getThreshold();
            const filtered = ipSummaryData.filter(row => row.minTime <= threshold);
            const sorted = [...filtered].sort((a, b) => {
                const col = mainSortCol;
                const aVal = col === 0 ? a.ip : (col === 3 ? a.minTime : a.fastPorts);
                const bVal = col === 0 ? b.ip : (col === 3 ? b.minTime : b.fastPorts);
                return mainSortDir === 'asc' ? 
                    (aVal < bVal ? -1 : 1) : 
                    (bVal < aVal ? -1 : 1);
            });

            ipSummaryBody.innerHTML = "";
            sorted.forEach(row => {
                const ipRow = ipSummaryBody.insertRow();
                const className = row.fastPorts >= 2 ? 'multi-port' : 
                                row.fastPorts >= 1 ? 'fast-row' : '';
                ipRow.className = className;
                
                ipRow.innerHTML = `
                    <td>${row.ip}</td>
                    <td>${row.fastPorts}</td>
                    <td class="port-list">${row.details}</td>
                    <td>${row.minTime.toFixed(0)}</td>
                    <td>${row.links}</td>
                `;
            });
        }

        function sortIPSummary(colIndex) {
            const isAsc = mainSortCol === colIndex && mainSortDir === 'asc';
            mainSortDir = isAsc ? 'desc' : 'asc';
            mainSortCol = colIndex;
            renderIPSummaryTable();
        }

        function scanPort(ip, port, callback) {
            const url = `${port === 80 ? 'http' : 'https'}://${ip}:${port}/?t=${Date.now()}`;
            const startTime = performance.now();
            
            fetch(url, {mode: 'no-cors'}).then(() => {
                callback(performance.now() - startTime);
            }).catch(() => {
                callback(performance.now() - startTime);
            });
        }

        function scanSubnet() {
            const prefix = netPrefixInput.value.trim();
            if (!/^(\d{1,3}\.){2}\d{1,3}$/.test(prefix)) {
                alert("Netblock prefix should look like 192.168.0");
                return;
            }
            
            const mode = modeSelect.value;
            clearTables();
            
            if (mode === 'smart') {
                // Smart scan logic here (same as before)
                setStatus("Smart scan: Port 80 baseline...");
                const p80Times = [];
                let p80Completed = 0;
                
                for (let i = 1; i <= 254; i++) {
                    const host = prefix + "." + i;
                    scanPort(host, 80, (time) => {
                        if (!allResponses.has(80)) allResponses.set(80, []);
                        allResponses.get(80).push({ip: host, time});
                        p80Completed++;
                        updateProgress(p80Completed, 254);
                        updateIPSummary();
                        
                        if (p80Completed === 254) {
                            setStatus("Smart scan complete");
                        }
                    });
                }
            } else {
                const ports = getPorts(mode);
                if (ports.length === 0) {
                    alert("Enter at least one port");
                    return;
                }
                
                ports.forEach(port => {
                    allResponses.set(port, []);
                    createPortTable(port);
                });
                
                setStatus(`Manual scan ${prefix}.1–254 on ports ${ports.join(', ')}...`);
                const totalRequests = 254 * ports.length;
                let completed = 0;
                
                ports.forEach(port => {
                    for (let i = 1; i <= 254; i++) {
                        const host = prefix + "." + i;
                        scanPort(host, port, (time) => {
                            const portData = allResponses.get(port);
                            portData.push({ip: host, time});
                            filterAndRenderPortTable(port);
                            updateIPSummary();
                            completed++;
                            updateProgress(completed, totalRequests);
                        });
                    }
                });
            }
        }

        // Event listeners
        startBtn.addEventListener('click', scanSubnet);
        clearBtn.addEventListener('click', clearTables);
        thresholdInput.addEventListener('input', updateIPSummary);
        
        // IP Summary table sorting
        document.querySelector('#ipSummaryTable thead th').forEach((th, index) => {
            th.addEventListener('click', () => sortIPSummary(index));
        });
        
        modeSelect.addEventListener('change', function() {
            portsLabel.style.display = this.value === 'ports' ? 'block' : 'none';
        });

        // Initial setup
        modeSelect.dispatchEvent(new Event('change'));
    </script>
</body>
</html>
