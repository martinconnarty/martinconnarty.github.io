<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subnet Port Timing Scanner</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f8f9fa; color: #333; }
        .input-panel { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        input[type="text"], input[type="range"] { width: 100%; padding: 12px; border: 2px solid #e0e6ed; border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        button { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin-top: 10px; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        .status { margin-top: 10px; padding: 10px; border-radius: 6px; }
        .status.running { background: #fff3cd; border: 1px solid #ffeaa7; }
        .status.error { background: #f8d7da; border: 1px solid #f5c6cb; }
        .mode-box { background: linear-gradient(135deg, #007bff, #0056b3); color: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; text-align: center; box-shadow: 0 4px 20px rgba(0,123,255,0.3); }
        .mode-stats { font-size: 18px; font-weight: 600; margin-bottom: 5px; }
        .mode-details { font-size: 14px; opacity: 0.9; }
        .toggle-panel { background: white; padding: 15px 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; display: flex; align-items: center; gap: 15px; }
        .toggle-btn { background: #28a745; padding: 10px 20px; border-radius: 25px; font-weight: 500; }
        .toggle-btn.active { background: #dc3545; }
        .results { display: flex; flex-direction: column; gap: 15px; }
        .ip-box { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); border-left: 5px solid #6c757d; opacity: 0.5; transform: translateX(-10px); transition: all 0.3s ease; }
        .ip-box.eligible { border-left-color: #007bff; opacity: 1; transform: translateX(0); }
        .ip-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .ip-addr { font-size: 20px; font-weight: 600; color: #1a1a1a; }
        .ip-time { font-family: monospace; font-size: 18px; font-weight: 600; color: #dc3545; }
        .ip-box.eligible .ip-time { color: #28a745; }
        .count-display { font-size: 16px; font-weight: 500; color: #495057; }
        .legend { display: flex; flex-wrap: wrap; gap: 20px; font-size: 14px; margin-top: 20px; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
        progress { width: 100%; height: 8px; border-radius: 4px; }
        .parallel-info { font-size: 12px; color: #666; margin-top: 5px; }
        .concurrency-display { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Subnet Port Timing Scanner</h1>
    
    <div class="input-panel">
        <label for="subnet">Subnet (CIDR):</label>
        <input type="text" id="subnet" value="192.168.68.0/24" placeholder="e.g. 192.168.68.0/24">
        <div class="concurrency-display">
            <label for="concurrency">Concurrency:</label>
            <input type="range" id="concurrency" min="5" max="50" value="20">
            <span id="concurrencyValue">20</span>
        </div>
        <div class="parallel-info">Higher = faster but may trigger browser/network limits</div>
        <button id="scanBtn">Start Mode-Based Port Sweep</button>
        <div id="status"></div>
        <progress id="progress" value="0" max="100" style="display: none;"></progress>
    </div>

    <div id="modeBox" class="mode-box" style="display: none;">
        <div class="mode-stats" id="modeStats"></div>
        <div class="mode-details" id="modeDetails"></div>
    </div>

    <div id="togglePanel" class="toggle-panel" style="display: none;">
        <button id="toggleBtn" class="toggle-btn">Hide Eligible (0)</button>
        <div class="count-display" id="countDisplay">0 total IPs scanned</div>
    </div>

    <div id="results" class="results"></div>

    <div class="legend">
        <div class="legend-item"><span class="legend-color" style="background: #007bff;"></span>Eligible (4x faster than mode)</div>
        <div class="legend-item"><span class="legend-color" style="background: #6c757d;"></span>Near mode cluster</div>
    </div>

    <script>
        const DEFAULT_SUBNET = '192.168.68.0/24';
        const PORT_80 = 80;
        const TIMEOUT_MS = 3000;
        const MODE_THRESHOLD_FACTOR = 4;

        let isScanning = false;
        let allPhase1Results = [];

        // Parse CIDR to IP range
        function parseSubnet(cidr) {
            const [net, bits] = cidr.split('/');
            const [a, b, c, d] = net.match(/\d+/g).map(Number);
            const mask = ~((1 << (32 - bits)) - 1);
            const start = (a << 24 | b << 16 | c << 8 | d) & mask;
            const end = start | (~mask >>> 0);
            const ips = [];
            for (let i = start; i <= end; i++) {
                const ip = [
                    (i >>> 24) & 255,
                    (i >>> 16) & 255,
                    (i >>> 8) & 255,
                    i & 255
                ].join('.');
                ips.push(ip);
            }
            return ips;
        }

        // ALL HTTPS port timing test
        async function testPort(ip, port) {
            const start = performance.now();
            try {
                const url = `https://${ip}:${port}/favicon.ico`;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                
                await fetch(url, {
                    method: 'GET',
                    signal: controller.signal,
                    mode: 'no-cors',
                    cache: 'no-cache'
                });
                clearTimeout(timeoutId);
                return Math.round(performance.now() - start);
            } catch (e) {
                return TIMEOUT_MS;
            }
        }

        // Calculate MODE from array of timings
        function calculateMode(times) {
            const bucketSize = 200;
            const buckets = {};
            times.forEach(time => {
                const bucket = Math.floor(time / bucketSize) * bucketSize;
                buckets[bucket] = (buckets[bucket] || 0) + 1;
            });
            let modeBucket = 0;
            let maxCount = 0;
            Object.entries(buckets).forEach(([bucket, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    modeBucket = parseInt(bucket);
                }
            });
            return modeBucket + bucketSize / 2;
        }

        // Parallel semaphore
        class Semaphore {
            constructor(concurrency) {
                this.concurrency = concurrency;
                this.queue = [];
                this.active = 0;
            }
            async acquire() {
                return new Promise(resolve => {
                    this.queue.push(resolve);
                    this._processQueue();
                });
            }
            release() {
                this.active--;
                this._processQueue();
            }
            _processQueue() {
                while (this.active < this.concurrency && this.queue.length > 0) {
                    this.active++;
                    this.queue.shift()();
                }
            }
        }

        // Phase 1: Mode-based sweep with ALL IPs shown
        async function phase1Sweep(ips, concurrency) {
            const semaphore = new Semaphore(concurrency);
            const statusEl = document.getElementById('status');
            const progressEl = document.getElementById('progress');
            
            statusEl.textContent = 'Collecting all port 80 timings for mode analysis...';
            progressEl.style.display = 'block';
            
            const allTimes = [];
            allPhase1Results = [];
            
            const phase1Promises = ips.map((ip, index) => 
                semaphore.acquire().then(async () => {
                    const time80 = await testPort(ip, PORT_80);
                    allTimes.push(time80);
                    const result = { ip, time80 };
                    allPhase1Results.push(result);
                    semaphore.release();
                    progressEl.value = (index / ips.length) * 100;
                    return result;
                })
            );
            
            await Promise.all(phase1Promises);
            
            // Calculate mode and threshold
            const modeTime = calculateMode(allTimes);
            const fastThreshold = modeTime / MODE_THRESHOLD_FACTOR;
            
            // Mark eligible
            allPhase1Results.forEach(result => {
                result.eligible = result.time80 <= fastThreshold;
            });
            
            // Show mode box
            document.getElementById('modeBox').style.display = 'block';
            document.getElementById('modeStats').textContent = `${Math.round(modeTime)}ms MODE`;
            document.getElementById('modeDetails').textContent = 
                `Threshold: ${Math.round(fastThreshold)}ms (${MODE_THRESHOLD_FACTOR}x faster) | ${allPhase1Results.filter(r => r.eligible).length} eligible`;
            
            // Show toggle panel
            document.getElementById('togglePanel').style.display = 'flex';
            updateToggleDisplay();
            
            renderPhase1Results();
            statusEl.textContent = `Phase 1 complete! ${allPhase1Results.filter(r => r.eligible).length} eligible IPs`;
        }

        // Render ALL phase 1 results with toggle
        function renderPhase1Results() {
            const resultsEl = document.getElementById('results');
            resultsEl.innerHTML = allPhase1Results
                .sort((a, b) => a.time80 - b.time80)
                .map(result => {
                    const eligibleClass = result.eligible ? 'eligible' : '';
                    return `
                        <div class="ip-box ${eligibleClass}" data-ip="${result.ip}">
                            <div class="ip-header">
                                <div class="ip-addr">${result.ip}</div>
                                <div class="ip-time">${result.time80}ms</div>
                            </div>
                            <div style="font-size: 14px; color: #666;">
                                ${result.eligible ? '✓ 4x faster than mode' : '○ Near mode cluster'}
                            </div>
                        </div>
                    `;
                }).join('');
        }

        // Toggle eligible visibility
        function toggleEligible() {
            const toggleBtn = document.getElementById('toggleBtn');
            const isShowingEligible = toggleBtn.classList.contains('active');
            
            document.querySelectorAll('.ip-box').forEach(box => {
                const ip = box.dataset.ip;
                const result = allPhase1Results.find(r => r.ip === ip);
                if (result.eligible) {
                    box.style.display = isShowingEligible ? 'none' : 'block';
                }
            });
            
            toggleBtn.classList.toggle('active');
            toggleBtn.textContent = isShowingEligible ? 'Hide Eligible (' + allPhase1Results.filter(r => r.eligible).length + ')' : 
                                   'Show Eligible Only (' + allPhase1Results.filter(r => r.eligible).length + ')';
            
            updateCountDisplay();
        }

        function updateToggleDisplay() {
            const eligibleCount = allPhase1Results.filter(r => r.eligible).length;
            document.getElementById('countDisplay').textContent = 
                `${eligibleCount} eligible / ${allPhase1Results.length} total`;
        }

        function updateCountDisplay() {
            updateToggleDisplay();
        }

        // Main scan (Phase 1 only for now)
        async function runScan() {
            const subnetInput = document.getElementById('subnet').value.trim() || DEFAULT_SUBNET;
            const concurrency = parseInt(document.getElementById('concurrency').value);
            
            const btn = document.getElementById('scanBtn');
            const statusEl = document.getElementById('status');
            
            if (isScanning) return;
            isScanning = true;
            btn.disabled = true;
            btn.textContent = 'Scanning...';
            statusEl.className = 'status running';
            statusEl.textContent = 'Parsing subnet...';
            
            try {
                const ips = parseSubnet(subnetInput);
                statusEl.textContent = `Found ${ips.length} IPs. Mode-based analysis (${concurrency} parallel)...`;
                
                document.getElementById('progress').value = 0;
                document.getElementById('modeBox').style.display = 'none';
                document.getElementById('togglePanel').style.display = 'none';
                document.getElementById('results').innerHTML = '';
                
                await phase1Sweep(ips, concurrency);
                
            } catch (error) {
                statusEl.className = 'status error';
                statusEl.textContent = `Error: ${error.message}`;
            } finally {
                isScanning = false;
                btn.disabled = false;
                btn.textContent = 'Re-run Port 80 Sweep';
            }
        }

        // Event listeners
        document.getElementById('scanBtn').addEventListener('click', runScan);
        document.getElementById('concurrency').addEventListener('input', function() {
            document.getElementById('concurrencyValue').textContent = this.value;
        });
        document.getElementById('toggleBtn').addEventListener('click', toggleEligible);

        // URL params
        const urlParams = new URLSearchParams(window.location.search);
        const subnetParam = urlParams.get('subnet');
        if (subnetParam) {
            document.getElementById('subnet').value = subnetParam;
        }
        document.getElementById('subnet').addEventListener('change', function() {
            const url = new URL(window.location);
            if (this.value) {
                url.searchParams.set('subnet', this.value);
            } else {
                url.searchParams.delete('subnet');
            }
            window.history.replaceState({}, '', url);
        });
    </script>
</body>
</html>
