<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subnet Port Timing Scanner</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f8f9fa; color: #333; }
        .input-panel { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        input[type="text"], input[type="range"] { width: 100%; padding: 12px; border: 2px solid #e0e6ed; border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        button { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin-top: 10px; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        .status { margin-top: 10px; padding: 10px; border-radius: 6px; }
        .status.running { background: #fff3cd; border: 1px solid #ffeaa7; }
        .status.error { background: #f8d7da; border: 1px solid #f5c6cb; }
        .results { display: flex; flex-direction: column; gap: 20px; }
        .host-box { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); border-left: 5px solid #007bff; }
        .host-ip { font-size: 24px; font-weight: 600; margin-bottom: 10px; color: #1a1a1a; }
        .timings { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .port-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #f8f9fa; border-radius: 6px; font-family: monospace; }
        .port-num { font-weight: 500; color: #495057; }
        .time-ms { font-weight: 600; color: #28a745; }
        .timeout { color: #dc3545; font-weight: 500; }
        .pills { display: flex; flex-wrap: wrap; gap: 8px; }
        .pill { padding: 8px 16px; border-radius: 20px; text-decoration: none; font-weight: 500; font-size: 14px; transition: all 0.2s; }
        .pill.http { background: #007bff; color: white; }
        .pill.https { background: linear-gradient(135deg, #28a745, #20c997); color: white; }
        .pill.likely { background: linear-gradient(135deg, #ffc107, #fd7e14); color: white; box-shadow: 0 2px 8px rgba(255,193,7,0.4); }
        .pill.down { background: #6c757d; color: white; opacity: 0.7; }
        .legend { display: flex; flex-wrap: wrap; gap: 20px; font-size: 14px; margin-top: 20px; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
        progress { width: 100%; height: 8px; border-radius: 4px; }
        .stats { font-size: 14px; color: #666; margin-bottom: 10px; }
        .parallel-info { font-size: 12px; color: #666; margin-top: 5px; }
        .concurrency-display { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Subnet Port Timing Scanner</h1>
    
    <div class="input-panel">
        <label for="subnet">Subnet (CIDR):</label>
        <input type="text" id="subnet" value="192.168.68.0/24" placeholder="e.g. 192.168.68.0/24">
        <div class="concurrency-display">
            <label for="concurrency">Concurrency:</label>
            <input type="range" id="concurrency" min="5" max="50" value="20">
            <span id="concurrencyValue">20</span>
        </div>
        <div class="parallel-info">Higher = faster but may trigger browser/network limits</div>
        <button id="scanBtn">Start Mode-Based Port Sweep</button>
        <div id="status"></div>
        <progress id="progress" value="0" max="100" style="display: none;"></progress>
    </div>

    <div id="results" class="results"></div>

    <div class="legend">
        <div class="legend-item"><span class="legend-color" style="background: #007bff;"></span>HTTP (80) - 4x faster than mode</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #28a745, #20c997);"></span>HTTPS - Likely open</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #ffc107, #fd7e14);"></span>Timing anomaly (4x faster)</div>
        <div class="legend-item"><span class="legend-color" style="background: #6c757d;"></span>Mode/Timeout cluster</div>
    </div>

    <script>
        const DEFAULT_SUBNET = '192.168.68.0/24';
        const PORT_80 = 80;
        const WEB_PORTS = [443, 8443, 8000, 8006, 8080, 8008];
        const BASELINE_PORTS = [123, 161, 179];
        const TIMEOUT_MS = 3000;
        const MODE_THRESHOLD_FACTOR = 4; // 4x quicker than mode

        let isScanning = false;

        // Parse CIDR to IP range
        function parseSubnet(cidr) {
            const [net, bits] = cidr.split('/');
            const [a, b, c, d] = net.match(/\d+/g).map(Number);
            const mask = ~((1 << (32 - bits)) - 1);
            const start = (a << 24 | b << 16 | c << 8 | d) & mask;
            const end = start | (~mask >>> 0);
            const ips = [];
            for (let i = start; i <= end; i++) {
                const ip = [
                    (i >>> 24) & 255,
                    (i >>> 16) & 255,
                    (i >>> 8) & 255,
                    i & 255
                ].join('.');
                ips.push(ip);
            }
            return ips;
        }

        // ALL HTTPS port timing test
        async function testPort(ip, port) {
            const start = performance.now();
            try {
                const url = `https://${ip}:${port}/favicon.ico`;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                
                await fetch(url, {
                    method: 'GET',
                    signal: controller.signal,
                    mode: 'no-cors',
                    cache: 'no-cache'
                });
                clearTimeout(timeoutId);
                return Math.round(performance.now() - start);
            } catch (e) {
                return TIMEOUT_MS;
            }
        }

        // Calculate MODE from array of timings
        function calculateMode(times) {
            const bucketSize = 200;
            const buckets = {};
            times.forEach(time => {
                const bucket = Math.floor(time / bucketSize) * bucketSize;
                buckets[bucket] = (buckets[bucket] || 0) + 1;
            });
            let modeBucket = 0;
            let maxCount = 0;
            Object.entries(buckets).forEach(([bucket, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    modeBucket = parseInt(bucket);
                }
            });
            return modeBucket + bucketSize / 2; // Center of mode bucket
        }

        // Parallel semaphore
        class Semaphore {
            constructor(concurrency) {
                this.concurrency = concurrency;
                this.queue = [];
                this.active = 0;
            }
            async acquire() {
                return new Promise(resolve => {
                    this.queue.push(resolve);
                    this._processQueue();
                });
            }
            release() {
                this.active--;
                this._processQueue();
            }
            _processQueue() {
                while (this.active < this.concurrency && this.queue.length > 0) {
                    this.active++;
                    this.queue.shift()();
                }
            }
        }

        // Phase 1: Mode-based port 80 sweep
        async function phase1Sweep(ips, concurrency) {
            const semaphore = new Semaphore(concurrency);
            const statusEl = document.getElementById('status');
            const progressEl = document.getElementById('progress');
            
            statusEl.textContent = 'Collecting all port 80 timings for mode analysis...';
            progressEl.style.display = 'block';
            
            const allTimes = [];
            const results = [];
            
            const phase1Promises = ips.map((ip, index) => 
                semaphore.acquire().then(async () => {
                    const time80 = await testPort(ip, PORT_80);
                    allTimes.push(time80);
                    results.push({ ip, time80 });
                    semaphore.release();
                    progressEl.value = (index / ips.length) * 50;
                    statusEl.textContent = `Phase 1: ${index + 1}/${ips.length} (${Math.round(time80)}ms)`;
                    return { ip, time80 };
                })
            );
            
            await Promise.all(phase1Promises);
            progressEl.value = 50;
            
            // Calculate mode and threshold
            const modeTime = calculateMode(allTimes);
            const fastThreshold = modeTime / MODE_THRESHOLD_FACTOR;
            
            statusEl.textContent = `Mode: ${Math.round(modeTime)}ms, Threshold: ${Math.round(fastThreshold)}ms (4x faster)`;
            
            // Filter candidates
            const candidates = results.filter(r => r.time80 <= fastThreshold);
            return candidates;
        }

        // Phase 2: Deep scan with per-IP mode analysis
        async function phase2Deepscan(candidates, concurrency) {
            const semaphore = new Semaphore(concurrency);
            const results = [];
            
            const deepscanPromises = candidates.map(async (cand, index) => {
                await semaphore.acquire();
                try {
                    const statusEl = document.getElementById('status');
                    const progressEl = document.getElementById('progress');
                    
                    statusEl.textContent = `Phase 2: ${cand.ip} (${index + 1}/${candidates.length})`;
                    progressEl.value = 50 + (index / candidates.length) * 50;
                    
                    // Test ALL ports for this IP (baseline + web)
                    const allPorts = [...BASELINE_PORTS, ...WEB_PORTS, PORT_80];
                    const allTimes = [];
                    const portTimes = {};
                    
                    // Parallel test all ports
                    const portPromises = allPorts.map(port => 
                        testPort(cand.ip, port).then(time => {
                            allTimes.push(time);
                            portTimes[port] = time;
                            return { port, time };
                        })
                    );
                    
                    await Promise.all(portPromises);
                    
                    // Calculate IP-specific mode
                    const ipMode = calculateMode(allTimes);
                    const ipThreshold = ipMode / MODE_THRESHOLD_FACTOR;
                    
                    // Likely open ports (4x faster than IP mode)
                    const likelyOpen = Object.entries(portTimes)
                        .filter(([p, t]) => Number(t) <= ipThreshold)
                        .map(([p]) => Number(p));
                    
                    results.push({
                        ...cand,
                        portTimes,
                        ipMode: Math.round(ipMode),
                        ipThreshold: Math.round(ipThreshold),
                        allTimes,
                        likelyOpen
                    });
                } finally {
                    semaphore.release();
                }
            });
            
            await Promise.all(deepscanPromises);
            return results;
        }

        // Render results
        function renderResults(hosts) {
            const resultsEl = document.getElementById('results');
            resultsEl.innerHTML = '';
            
            hosts.forEach(host => {
                const box = document.createElement('div');
                box.className = 'host-box';
                
                const pills = [
                    `<a href="http://${host.ip}" class="pill http" target="_blank">HTTP:80 (${host.time80}ms)</a>`
                ];
                
                WEB_PORTS.forEach(port => {
                    const time = host.portTimes[port] || TIMEOUT_MS;
                    const isLikely = host.likelyOpen.includes(port);
                    const protocol = port === 443 ? `https://${host.ip}` : `https://${host.ip}:${port}`;
                    const status = isLikely ? 'likely' : (time >= TIMEOUT_MS ? 'down' : 'down');
                    pills.push(`<a href="${protocol}" class="pill ${status}" target="_blank">${port} (${time}ms)</a>`);
                });
                
                box.innerHTML = `
                    <div class="host-ip">${host.ip}</div>
                    <div class="stats">
                        P80: ${host.time80}ms | IP Mode: ${host.ipMode}ms | Threshold: ${host.ipThreshold}ms
                    </div>
                    <div class="pills">${pills.join('')}</div>
                    <div class="timings">
                        ${Object.entries(host.portTimes).sort(([a],[b])=>a-b).map(([p, t]) => 
                            `<div class="port-row">
                                <span class="port-num">Port ${p}</span>
                                <span class="time-ms ${t >= TIMEOUT_MS ? 'timeout' : ''}">${t}ms</span>
                            </div>`
                        ).join('')}
                        <div class="port-row">
                            <span class="port-num">IP Mode</span>
                            <span class="time-ms">${host.ipMode}ms</span>
                        </div>
                    </div>
                `;
                resultsEl.appendChild(box);
            });
        }

        // Main scan
        async function runScan() {
            const subnetInput = document.getElementById('subnet').value.trim() || DEFAULT_SUBNET;
            const concurrency = parseInt(document.getElementById('concurrency').value);
            
            const btn = document.getElementById('scanBtn');
            const statusEl = document.getElementById('status');
            
            if (isScanning) return;
            isScanning = true;
            btn.disabled = true;
            btn.textContent = 'Scanning...';
            statusEl.className = 'status running';
            statusEl.textContent = 'Parsing subnet...';
            
            try {
                const ips = parseSubnet(subnetInput);
                statusEl.textContent = `Found ${ips.length} IPs. Mode-based analysis (${concurrency} parallel)...`;
                
                document.getElementById('progress').style.display = 'block';
                document.getElementById('progress').value = 0;
                
                const candidates = await phase1Sweep(ips, concurrency);
                
                if (candidates.length === 0) {
                    statusEl.textContent = `No candidates found (all near mode cluster)`;
                    return;
                }
                
                statusEl.textContent = `${candidates.length} candidates (4x faster than mode). Deep scan...`;
                const results = await phase2Deepscan(candidates, concurrency);
                
                renderResults(results);
                statusEl.textContent = `Complete! ${results.length} hosts analyzed using mode detection.`;
            } catch (error) {
                statusEl.className = 'status error';
                statusEl.textContent = `Error: ${error.message}`;
            } finally {
                isScanning = false;
                btn.disabled = false;
                btn.textContent = 'Start Mode-Based Port Sweep';
                document.getElementById('progress').style.display = 'none';
            }
        }

        // Event listeners
        document.getElementById('scanBtn').addEventListener('click', runScan);
        document.getElementById('concurrency').addEventListener('input', function() {
            document.getElementById('concurrencyValue').textContent = this.value;
        });

        // URL params
        const urlParams = new URLSearchParams(window.location.search);
        const subnetParam = urlParams.get('subnet');
        if (subnetParam) {
            document.getElementById('subnet').value = subnetParam;
        }
        document.getElementById('subnet').addEventListener('change', function() {
            const url = new URL(window.location);
            if (this.value) {
                url.searchParams.set('subnet', this.value);
            } else {
                url.searchParams.delete('subnet');
            }
            window.history.replaceState({}, '', url);
        });
    </script>
</body>
</html>
