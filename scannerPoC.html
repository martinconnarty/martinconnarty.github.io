<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subnet Port Timing Scanner</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f8f9fa; color: #333; }
        .input-panel { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        input[type="text"] { width: 100%; padding: 12px; border: 2px solid #e0e6ed; border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        button { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin-top: 10px; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        .status { margin-top: 10px; padding: 10px; border-radius: 6px; }
        .status.running { background: #fff3cd; border: 1px solid #ffeaa7; }
        .status.error { background: #f8d7da; border: 1px solid #f5c6cb; }
        .results { display: flex; flex-direction: column; gap: 20px; }
        .host-box { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); border-left: 5px solid #007bff; }
        .host-ip { font-size: 24px; font-weight: 600; margin-bottom: 10px; color: #1a1a1a; }
        .timings { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .port-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #f8f9fa; border-radius: 6px; font-family: monospace; }
        .port-num { font-weight: 500; color: #495057; }
        .time-ms { font-weight: 600; color: #28a745; }
        .timeout { color: #dc3545; font-weight: 500; }
        .pills { display: flex; flex-wrap: wrap; gap: 8px; }
        .pill { padding: 8px 16px; border-radius: 20px; text-decoration: none; font-weight: 500; font-size: 14px; transition: all 0.2s; }
        .pill.http { background: #007bff; color: white; }
        .pill.https { background: linear-gradient(135deg, #28a745, #20c997); color: white; }
        .pill.likely { background: linear-gradient(135deg, #ffc107, #fd7e14); color: white; box-shadow: 0 2px 8px rgba(255,193,7,0.4); }
        .pill.down { background: #6c757d; color: white; opacity: 0.7; }
        .legend { display: flex; gap: 20px; font-size: 14px; margin-top: 20px; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
        progress { width: 100%; height: 8px; border-radius: 4px; }
        .stats { font-size: 14px; color: #666; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Subnet Port Timing Scanner</h1>
    
    <div class="input-panel">
        <label for="subnet">Subnet (CIDR):</label>
        <input type="text" id="subnet" value="192.168.68.0/24" placeholder="e.g. 192.168.68.0/24">
        <button id="scanBtn">Start Port Sweep</button>
        <div id="status"></div>
        <progress id="progress" value="0" max="100" style="display: none;"></progress>
    </div>

    <div id="results" class="results"></div>

    <div class="legend">
        <div class="legend-item"><span class="legend-color" style="background: #007bff;"></span>HTTP (80) - Fast response</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #28a745, #20c997);"></span>HTTPS - Likely open</div>
        <div class="legend-item"><span class="legend-color" style="background: linear-gradient(135deg, #ffc107, #fd7e14);"></span>Timing anomaly</div>
        <div class="legend-item"><span class="legend-color" style="background: #6c757d;"></span>Timeout / Slow</div>
    </div>

    <script>
        const DEFAULT_SUBNET = '192.168.68.0/24';
        const PORT_80 = 80;
        const WEB_PORTS = [443, 8443, 8000, 8006, 8080, 8008];
        const TIMEOUT_MS = 3000;
        const BASELINE_PORTS = [123, 161, 179]; // UDP-like ports unlikely to respond
        const FAST_THRESHOLD = 1200; // Much lower threshold for phase 1
        const SUBNET_BASELINE_SAMPLES = 10; // Sample first N hosts for subnet baseline

        let isScanning = false;
        let subnetBaseline = null;

        // Parse CIDR to IP range
        function parseSubnet(cidr) {
            const [net, bits] = cidr.split('/');
            const [a, b, c, d] = net.match(/\d+/g).map(Number);
            const mask = ~((1 << (32 - bits)) - 1);
            const start = (a << 24 | b << 16 | c << 8 | d) & mask;
            const end = start | (~mask >>> 0);
            const ips = [];
            for (let i = start; i <= end; i++) {
                const ip = [
                    (i >>> 24) & 255,
                    (i >>> 16) & 255,
                    (i >>> 8) & 255,
                    i & 255
                ].join('.');
                ips.push(ip);
            }
            return ips;
        }

        // Improved port timing test - uses image fetch for better cross-origin timing
        async function testPort(ip, port, protocol = 'http') {
            const start = performance.now();
            try {
                // Use 1x1 pixel fetch - more reliable than HEAD for timing
                const url = `${protocol}://${ip}:${port === 80 ? '' : port}/favicon.ico`;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                
                const response = await fetch(url, {
                    method: 'GET',
                    signal: controller.signal,
                    mode: 'no-cors',
                    cache: 'no-cache'
                });
                clearTimeout(timeoutId);
                
                // Even in no-cors, connection timing is measurable
                return Math.round(performance.now() - start);
            } catch (e) {
                return TIMEOUT_MS;
            }
        }

        // Calculate subnet-wide baseline (avg of first N hosts on random high ports)
        async function calculateSubnetBaseline(ips) {
            const sampleIps = ips.slice(0, Math.min(SUBNET_BASELINE_SAMPLES, ips.length));
            const allTimes = [];
            
            for (const ip of sampleIps) {
                for (const port of BASELINE_PORTS) {
                    const time = await testPort(ip, port, 'http');
                    allTimes.push(time);
                }
            }
            return allTimes.reduce((a, b) => a + b, 0) / allTimes.length;
        }

        // Phase 1: Find fast hosts on port 80 vs SUBNET baseline
        async function phase1Sweep(ips) {
            const statusEl = document.getElementById('status');
            const progressEl = document.getElementById('progress');
            
            // First calculate subnet baseline
            statusEl.textContent = 'Calculating subnet baseline...';
            subnetBaseline = await calculateSubnetBaseline(ips);
            statusEl.textContent = `Subnet baseline: ${Math.round(subnetBaseline)}ms`;
            
            progressEl.style.display = 'block';
            const candidates = [];
            
            for (let i = 0; i < ips.length; i++) {
                const ip = ips[i];
                statusEl.textContent = `Phase 1: Testing ${ip} port 80 (${i + 1}/${ips.length})`;
                progressEl.value = (i / ips.length) * 50;
                
                const time80 = await testPort(ip, PORT_80);
                
                // Much more lenient: anything < 2x subnet baseline AND < 2s
                if (time80 < subnetBaseline * 2 && time80 < 2000) {
                    candidates.push({ ip, time80 });
                    statusEl.textContent += ` âœ“ Fast: ${time80}ms`;
                }
                
                await new Promise(r => setTimeout(r, 30)); // Faster rate limit
            }
            progressEl.value = 50;
            return candidates;
        }

        // Phase 2: Deep scan web ports + establish IP-specific baseline
        async function phase2Deepscan(candidates) {
            const statusEl = document.getElementById('status');
            const progressEl = document.getElementById('progress');
            
            const results = [];
            for (let i = 0; i < candidates.length; i++) {
                const cand = candidates[i];
                statusEl.textContent = `Phase 2: Deep scan ${cand.ip} (${i + 1}/${candidates.length})`;
                progressEl.value = 50 + (i / candidates.length) * 50;
                
                // Get IP-specific baseline first
                const baselineTimes = await Promise.all(
                    BASELINE_PORTS.map(p => testPort(cand.ip, p, 'http'))
                );
                const ipBaseline = baselineTimes.reduce((a, b) => a + b, 0) / baselineTimes.length;
                
                const portTimes = { 80: cand.time80 };
                
                // Test all web ports
                const webTimes = await Promise.all(
                    WEB_PORTS.map(port => testPort(cand.ip, port, 'https'))
                );
                
                WEB_PORTS.forEach((port, idx) => {
                    portTimes[port] = webTimes[idx];
                });
                
                // Mark likely open ports: < 1.3x IP baseline AND < 80% of timeout
                const likelyOpen = Object.entries(portTimes)
                    .filter(([p, t]) => {
                        const time = Number(t);
                        return time < ipBaseline * 1.3 && time < TIMEOUT_MS * 0.8;
                    })
                    .map(([p]) => Number(p));
                
                results.push({ 
                    ...cand, 
                    portTimes, 
                    ipBaseline: Math.round(ipBaseline),
                    subnetBaseline: Math.round(subnetBaseline),
                    likelyOpen 
                });
                
                await new Promise(r => setTimeout(r, 80));
            }
            return results;
        }

        // Render results (unchanged)
        function renderResults(hosts) {
            const resultsEl = document.getElementById('results');
            resultsEl.innerHTML = '';
            
            hosts.forEach(host => {
                const box = document.createElement('div');
                box.className = 'host-box';
                
                const pills = [
                    `<a href="http://${host.ip}" class="pill http" target="_blank">HTTP:80 (${host.time80}ms)</a>`
                ];
                
                WEB_PORTS.forEach(port => {
                    const time = host.portTimes[port];
                    const isLikely = host.likelyOpen.includes(port);
                    const protocol = port === 443 ? `https://${host.ip}` : `https://${host.ip}:${port}`;
                    const status = isLikely ? 'likely' : (time >= TIMEOUT_MS ? 'down' : 'down');
                    pills.push(`<a href="${protocol}" class="pill ${status}" target="_blank">${port} (${time}ms)</a>`);
                });
                
                box.innerHTML = `
                    <div class="host-ip">${host.ip}</div>
                    <div class="stats">
                        Subnet baseline: ${host.subnetBaseline}ms | IP baseline: ${host.ipBaseline}ms
                    </div>
                    <div class="pills">${pills.join('')}</div>
                    <div class="timings">
                        ${Object.entries(host.portTimes).map(([p, t]) => 
                            `<div class="port-row">
                                <span class="port-num">Port ${p}</span>
                                <span class="time-ms ${t >= TIMEOUT_MS ? 'timeout' : ''}">${t}ms</span>
                            </div>`
                        ).join('')}
                        <div class="port-row">
                            <span class="port-num">IP baseline</span>
                            <span class="time-ms">${host.ipBaseline}ms</span>
                        </div>
                    </div>
                `;
                resultsEl.appendChild(box);
            });
        }

        // Main scan function (unchanged structure)
        async function runScan() {
            const subnetInput = document.getElementById('subnet').value.trim();
            const subnet = subnetInput || DEFAULT_SUBNET;
            
            const btn = document.getElementById('scanBtn');
            const statusEl = document.getElementById('status');
            
            if (isScanning) return;
            isScanning = true;
            btn.disabled = true;
            btn.textContent = 'Scanning...';
            statusEl.className = 'status running';
            statusEl.textContent = 'Parsing subnet...';
            
            try {
                const ips = parseSubnet(subnet);
                statusEl.textContent = `Found ${ips.length} IPs. Starting scan...`;
                
                const candidates = await phase1Sweep(ips);
                if (candidates.length === 0) {
                    statusEl.textContent = `No fast hosts found. Subnet baseline was ${Math.round(subnetBaseline)}ms. Try a different subnet.`;
                    return;
                }
                
                statusEl.textContent = `Phase 1: ${candidates.length} candidates found. Phase 2...`;
                const results = await phase2Deepscan(candidates);
                
                renderResults(results);
                statusEl.textContent = `Complete! ${results.length} hosts analyzed.`;
            } catch (error) {
                statusEl.className = 'status error';
                statusEl.textContent = `Error: ${error.message}`;
            } finally {
                isScanning = false;
                btn.disabled = false;
                btn.textContent = 'Start Port Sweep';
                document.getElementById('progress').style.display = 'none';
            }
        }

        document.getElementById('scanBtn').addEventListener('click', runScan);

        // URL params support (unchanged)
        const urlParams = new URLSearchParams(window.location.search);
        const subnetParam = urlParams.get('subnet');
        if (subnetParam) {
            document.getElementById('subnet').value = subnetParam;
        }

        document.getElementById('subnet').addEventListener('change', function() {
            const url = new URL(window.location);
            if (this.value) {
                url.searchParams.set('subnet', this.value);
            } else {
                url.searchParams.delete('subnet');
            }
            window.history.replaceState({}, '', url);
        });
    </script>
</body>
</html>
